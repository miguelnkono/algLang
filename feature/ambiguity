Ambiguity in a grammar is when two productions rules produce the same string. Given that string how
do we know which production produced it??

So here is the first version of the grammar supporting only arithmetic operations : (ambiguous)
expr      -> literal | unary | binary | grouping ;
literal         -> NUMBER | STRING | "vrai" | "faux" | "nil" ;
unary           -> ("-", "!") expr ;
grouping        -> "(" expr ")" ;
binary          -> expr operator expr ;
operator        -> "==" | "<=" | ">=" | "<" | ">" | "+" | "-" | "*" | "/" ;

To address this ambiguity we introduce the operator precedence and associative rules borrow from
mathematicians.
The precedence rule tell us which operator is evaluated first in a series of different operators.
The associative rul tell us which operator is evaluated first in a series of same operators,
arithmetics exprs are left-associative where the assignment is right-associative.

With that here is the correct grammar with unambiguity in it :
expr      -> equality ;
equality        -> comparison (("!=" | "==") comparison)* ;
comparison      -> term ((">" | ">=" | "<" | "<=") term)* ;
term            -> factory (("+"| "-") factor)* ;
factor          -> unary (("/"| "*") unary)* ;
unary           -> ("!"| "-") unary | primary ;
primary         -> NUMBER | STRING | "vrai" | "faux" | "nil" | "(" expr ")" ;
